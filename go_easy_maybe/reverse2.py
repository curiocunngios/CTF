import sys 

def split_mul_result(a, b):
    result = a * b
    rax = result & ((1 << 64) - 1)    # low 64 bits
    rdx = result >> 64                 # high 64 bits
    return rdx, rax
'''
- understand behaviour of the program 
- understand 
- know exactly what it does
- we go agane
'''
rbp_0x4 = 0x2 # i = 2
f = bytearray(0x100000) # uninitialized
s = bytearray(0x100000)
data = bytes([
    0x4b, 0x26, 0x44, 0x2d, 0x53, 0x6f, 0x57, 0x01,
    0x58, 0xd9, 0x49, 0x81, 0x64, 0x2c, 0x86, 0x50,
    0x6a, 0xde, 0x86, 0x0c, 0xc0, 0xc7, 0xa8, 0xbd,
    0x24, 0x54, 0xd2, 0x6b, 0xa3, 0xb7, 0xc0, 0x94,
    0xc0, 0x81, 0xa0, 0xad, 0x80, 0x00, 0x00, 0x00
])

while (rbp_0x4 <= 0x24):
    ecx = f[rbp_0x4 - 2] & 0xFF
    eax = f[rbp_0x4 - 1] & 0xFF

    ecx = ecx + eax 

    f[rbp_0x4] = ecx & 0xFF

    rbp_0x4 = rbp_0x4 + 1

rbp_0x8 = 0x0

while (rbp_0x8 <= 0x24):
    s[rbp_0x8] = int.from_bytes(sys.stdin.buffer.read(1), 'little') # scanf(%c, s[j])
    
    ecx = s[rbp_0x8] & 0xFF
    eax = f[rbp_0x8] & 0xFF

    s[rbp_0x8] = (ecx + eax ) & 0xFF


    
    rbp_0x8 = rbp_0x8 + 1
rbp_0xc = 0
rbp_0x10 = 0

while (rbp_0x10 <= 0x24):
    

    rcx = rbp_0x10 + 0x24
    rdx = (rcx * 0xdd67c8a60dd67c8b) >> 69  # Combined mul and shifts
    rax = ((rdx << 3) + rdx) << 2 + rdx     # Simplified multiplication
    idx = rcx - rax
    
    idx = rcx - rax
    print(idx)
    s[rbp_0x10] = (s[rbp_0x10] ^ s[idx + rbp_0x10]) & 0xFF

    dl = s[rbp_0x10] & 0xFF

    al = data[rbp_0x10] & 0xFF

    if (dl == al):
        rbp_0xc = rbp_0xc + 1
    rbp_0x10 = rbp_0x10 + 1


if (rbp_0xc == 0x25):
    print(":D")
else:
    print(":(")